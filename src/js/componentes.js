

import { Todo } from '../classes';
import { listaDeTareas } from '../index';

// Referencias en el HTML

const divTodoList 	  = document.querySelector('.todo-list'); 		// selecciono el elemento <ul> a través de la clase (.todo-list) con la que lo estoy identificando, ese elemento <ul> tiene cada <li> o listing item, luego simplemente lo selecciono con el nombre de la const: "divTodoList" (nombre de la constante que está almacenando esa selección) y agregarle el HTML o la estructura de cada "to do" mediante el método "append" y diciéndole que es lo que quiero agregar mediante el método "append" (en este caso, lo que quiero agregar, es todo el código HTML dinámico que estoy guardando o almacenando en la constante "htmlTodo", pero antes de eso, cree un elemento "div" almacenando en una constante la creación de dicho elemento en "const": "div" y cuando almacene la creación de ese elemento en esa constante, dije que se agregara en ese elemento "div", todo el código HTML que se estaba almacenando en la constante "htmlTodo", hecho eso, agregue mediante el método "append", el div que se creo con todo el código html que guardaba o almacenaba la constante "htmlTodo")
const txtInput 	  	  = document.querySelector('.new-todo'); 		// selecciono el elemento <input> a través de la clase (.new-todo), ese "input" es el que me permite en mi estructura HTML agregar o añadir nuevos "to do" o "tareas"
const btnBorrar 	  = document.querySelector('.clear-completed'); // selecciono el botón <button> a través de la clase (.clear-completed), ese "button" es el que me permite en mi estructura HTML borrar todos los "todos" que estén completados
const ulFiltros		  = document.querySelector('.filters'); 		// Referencia, que guarda la selección al elemento <ul> o lista desordenada, que dentro contiene "listing items" o <li>, los cuales son cada uno de los botones de filtro ("todos", "completados", "pednientes")
const aFiltro		  = document.querySelectorAll('.filtro'); 		// Se almacena la selección a cada <li> o botón dentro de mi <ul> de filtros. De esta manera, selecciono todos los <li> o botones que me permiten hacer el filtrado


export const crearTodoHtml = ( todo ) => {

    const htmlTodo = `
    <li class="${ (todo.completado) ? 'completed' : '' }" data-id="${ todo.id }">
		<div class="view">
			<input class="toggle" type="checkbox" ${ (todo.completado) ? 'checked' : '' }>
			<label>${ todo.tarea }</label>
			<button class="destroy"></button>
		</div>
		<input class="edit" value="Creado por Álvaro">
	</li>`; // guardo o almaceno en una constante lo que debo insertar cada vez que se cree un "to do" o "tarea", es decir, todo lo que contiene cada "to do". En otras palabras, se almacena en una constante, todo lo que contiene y compone cada "tarea" para insertar cada vez que se crea una "tarea" nueva, pero con info dinámica, como el contenido de la tarea, el ID, si está completada o no, etc. Se almacena en una constante la estructura HTML del "to do", para insertar cada vez que se crea un "to do" nuevo, pero cambiando la info de manera dinámica de lo que contiene el "to do"

    const div = document.createElement('div'); // almaceno en una constante la creación de un "div"
    div.innerHTML = htmlTodo; // Inserto en ese div anteriormente creado, todo lo que guardé en la "const": "htmlTodo"

    divTodoList.append( div.firstElementChild ); // selecciono el elemento <ul> e inserto lo que se crea en la "const": "div"

    return div.firstElementChild;

}


// Eventos

txtInput.addEventListener( 'keyup', ( event ) => {

	if ( event.keyCode === 13 && txtInput.value.length > 0 ) { // acá estoy diciendo que si la tecla que se presiono tiene un "keyCode" exactamente igual a "13", y el largo o "length" del valor o "value" de lo que escribí en el input que se está almacenando en la constante "txtInput" es mayor ">" a "0", entonces que se ejecute el código entre llaves. Ambas condiciones deben cumplirse, que el "length" de "txtInput.value" sea mayor a "0" (es decir que el valor o "value" de lo que se escribió en el input que se está almacenando en "txtInput" no sea un string vacío) y que la tecla que se haya apretado sea la que tiene el "keyCode" igual a "13"

		const nuevoTodo = new Todo ( txtInput.value ); // txtInput es una constante que está almcenando la referencia o la selección al elemento <input> y mediante "value", obtengo el valor que tiene dentro ese "input" (puede ser texto, numero, contraseña, telefono, todos los valores y/o datos que puede recibir un "input"). Entonces, cuando creo una nueva instancia de mi clase "Todo", le paso como argumento lo que escribí en ese input que se está almacenando en al constante "txtInput", recordemos que lo que yo le pase como argumento a esa nueva instancia de mi clase, va a ser el valor de la propiedad "tarea" de mi clase "Todo", en este caso, lo que yo escribí en el input, es lo que estoy enviando como argumento en la creación de mi nueva instancia de la clase, y por consiguiente, ese es el valor que va a tener la propiedad "tarea" de mi clase "Todo" en la instancia "nuevoTodo" (que es la constante que está almacenando la creación de la nueva instancia de mi clase "Todo", y la cual tiene como argumento, lo que yo escribí en el input, por ende, ese es el valor que va a tener la propiedad "tarea" de mi clase "Todo", para la nueva instancia que se creó, mediante la constante "nuevoTodo"... siendo la propiedad "tarea" la parte visible de mi "todo")
		listaDeTareas.nuevoTodo( nuevoTodo ); 
		// más arriba importé la constante "listaDeTarea" la cual almacena la lista de "Todos", es decir, el array vació que va a contener todos mis "Todos"... a través del método ".nuevoTodo", puedo agregar un elemento a ese array vacío gracias al método "push" que se ejecuta dentro del método ".nuevoTodo", lo que yo le envío como argumento es lo que se va a agregar al array, ¿qué agrego a ese array? lo que le envío como argumento al método o función el cual se creó en el archivo /classes/todo-list.class.js y tiene como nombre ".nuevoTodo". En este caso, le envío como argumento la creación de una nueva instancia de mi clase "Todo", y el argumento de esa nueva instancia de mi clase es mi: "to do" o la parte visible de mi "tarea", en este caso es el contenido o "value" de mi elemento "input", es decir, lo que yo escribí en mi elemento "input" (el "value" del "input") es lo que le paso como argumento (y como valor para mi propiedad "tarea") a esta nueva instancia de mi clase "Todo", y eso que yo estoy enviando como argumento (el "value" de mi "input" que se está almacenando en "txtInput") va a ser el valor que adopte la propiedad "tarea" de mi clase "Todo" para esa instancia nueva que estoy creando y almacenando en la constante "nuevoTodo"... En otras palabras, lo que yo le paso como argumento a este método, es un "todo" (o una nueva instancia de mi clase "Todo") y ese "todo" es lo que se inserta en el array mediante el método "push" que me permite insertar elementos nuevos a un array, en este caso, se inserta al array una nueva instanancia de mi clase "Todo", la cual recibe como argumento una "tarea" o el valor que va a tener la propiedad "tarea" de esa nueva instancia que estoy creando, entonces, en esta línea de código recibo como argumento la creación de una nueva instancia de mi clase "Todo", esta nueva instancia se está almacenando en la constante "nuevoTodo", esa constante almacena una nueva instancia y recibe como argumento el valor que va a tener la propiedad "tarea" de esta nueva instancia de mi clase "Todo", y el valor que va a tener esa propiedad es el "value" de mi "input", es decir, lo que yo escriba en ese "input" es el valor que le estoy pasando a mi propiedad "tarea" para esa nueva instancia de mi clase "Todo" que se almacena en la constante "nuevoTodo"............................... En resumen, creo una nueva instancia de mi clase, le paso como argumento el valor que quiero que tenga la propiedad "tarea" de esta nueva instancia (en este caso es el "value" de mi "input" o lo que se escribió en el "input"), esta propiedad "tarea" se va a utilizar como el contenido de la "tarea", luego, mediante el método ".nuevoTodo" inserto un nuevo elemento a mi array que contiene todos mis "todos" o "tareas", y lo que inserto es esa nueva instancia que se está almacenando en la constante "nuevoTodo"

		crearTodoHtml( nuevoTodo ); 
		// Utilizó la función de "crearTodoHtml" la cual almacena la estructura HTML del "todo", con los datos dinámicos que debe tener cada "to do", como: "tarea", "id", "estado"; la función también crea un elemento "div" en el cual inserta todo este HTML que compone cada "to do" y lo inserta donde corresponde que es en el elemento <ul> (el padre de cada elemento <li>). Lo que recibe como argumento esta función, es el "to do", a través de lo que recibe como argumento, es que identifica los valores que corresponden a la propiedad "tarea", "completado", "id" de cada "to do", es decir, a traves de lo que recibe como argumento y de la creación de una nueva instancia es que identifica los valores que deben tener cada una de las propiedades que componen la clase "Todo", los valores que van a tener estas propiedades, se definen en cada instancia, ya sea en el argumento que se envía en esa nueva instancia, o todos los datos que se guardan con la creación de la nueva instancia, luego de identificar el valor de cada una de las propiedades de mi clase, coloca dichos valores en donde sea que se están utilizando en el HTML almacenado en la constante "htmlTodo"... esa constante que contiene el HTML que compone cada "to do", utiliza los valores de estas propiedades para mostrar información dinámica, una vez que tiene los valores de cada propiedad de mi clase, los coloca donde corresponde o donde se estén utilizando. Es decir, lo que yo le envíe como argumento a esta función, es lo que va a usar para definir la propiedad "tarea", "completado" e "id". En este caso, le envío como argumento la constante "nuevoTodo", esta constante está almacenando la creación de una nueva instancia de mi clase "Todo", por ende, esta instancia esta definiendo valores para las propiedades "tarea", "completado", "id" de la clase "Todo", valores los cuales se van a utilizar para colocar en los diferentes elementos HTML en los que se los está llamando, haciendo referencia o utilizando como valor a mostar, como por ejemplo en el elemento <label> que se utiliza el valor o el contenido de la propiedad "tarea" para mostrar en dicho elemento <label>, tmabien la "clase" que va a tener el <li> y va definir si se muestra como "completed" o no, se toma de manera dinámica de acuerdo al valor que tenga la propiedad "completado" de la clase "Todo"................................................................ La constante "htmlTodo" tiene todo el código HTML que compone a un "to do", este código está compuesto por información dinámica como la "tarea", si está "completado" o no, toda esa información dinámica, se obtiene de cada instancia, es decir, son propiedades de mi clase, las cuales obtienen un valor en cada instancia... el valor de la propiedad "tarea" es un valor que se define en la creación de una nueva instancia de mi clase, en este caso, como el argumento de la creación de esta instancia. Una vez que yo tenga un valor para esa propiedad "tarea", los lugares de mi HTML que ocupan el valor de la propiedad "tarea" para mostra info dinámica en base al valor que tenga esa propiedad, el cual se define por lo que escriba en el "input" o su "value", simplemente van a mostrar ese valor en lugar de ${todo.tarea}

		txtInput.value = ''; // después de insertar "to do", deja el elemento "input" almacenado en la constante "txtInput" vacío

	}

} );

// "keyup" es el evento que voy a estar buscando que suceda para disparar todo el código que hay dentro de las "{}"... se dispara ese código cuando sucede ese evento en mi elemento <input> con la clase ".new-todo" gracias al método de "addEventListener"... todo eso afecta a la constante "txtInput" que está almacenando la selección del elemento "input" de mi HTML, mediante la clase que tiene el dicho elemento <input>, responsable de agregar nuevas notas, o eso debería hacer, o eso estamos buscando que haga mediante el método "addEventListener" y el evento "keyup"

// "keyup" -> evento que, cuando el usuario suelta una tecla, dispara todo el código entre "{}"

// "event" o el argumento que recibe esa función de flecha anidada en el método de "addEventListener" nos dice cuáles son las teclas que oprime el usuario, además de todo lo que lleva escribiendo, algo muy útil, de esa manera, podemos saber lo que lleva escrito mediante el "value" y las teclas que oprime mediante el "keyCode", cada tecla tiene un "keyCode", así yo puedo indetificar cuándo oprimió "enter" o la tecla con el "keyCode = 13", y que cuando oprima la tecla con ese "keyCode" se inserte una nueva nota, o disparar el código entre llaves, es decir, en caso que el usuario oprima la tecla con el "keyCode" que tiene la tecla que a mi me interesa que dispare el código (en el elemento que a mi me interesa, en este caso el <input>), se debe disparar el código entre llaves, siempre y cuando oprima esa tecla en el elemento que está almacenando la constante "txtInput", es decir, no me interesa que siempre, en cualquier lugar de mi aplicación, cuando oprima esa tecla con el "keyCode" especificado, se dispare el código, me interesa que ese código se dispare cuando oprimo la tecla con ese "keyCode", en el elemento que estoy seleccionando mediante la constante "txtInput", el cual es: el input con la clase .new-todo
// "event" o el argumento que recibe esa función de flecha anidada en el método de "addEventListener" nos dice cuál es la tecla que se oprime, es decir, "keyup" es un evento, cuando sucede ese evento, disparo el código entre llaves, y... ¿cuándo sucede ese evento? cuando yo oprimo una tecla... ¿cuál tecla? mediante "event" o el argumento que recibe la función de flecha que está dentro del método "addEventListener", yo puedo saber qué teclas se están oprimiendo y enviar la señal de que el eventó sucedió para que se dispare el código, cuando se oprime una tecla con el "keyCode" que a mi me interesa, como puede ser la tecla "enter". En otras palabras, sabiendo las teclas que se oprimen y los "keyCodes" de las mismas, puedo saber cuándo se oprime una tecla que a mi me interese que dispare el código... y, decir que, en caso de ser oprimida la tecla con el "keyCode" igual a "13", se dispare el código entre llaves


/*

Primero, creo la nueva instancia (const nuevoTodo = new Todo ( txtInput.value ))
Segundo, agrego esa instancia al array que contiene todos mis "Todos" (listaDeTareas.nuevoTodo( nuevoTodo ))
Tercero, inserto esa nueva instancia que cree en el PRIMER paso y que almacene en mi array de "Todos" en el SEGUNDO paso, la inserto en el HTML (crearTodoHtml( nuevoTodo ))
Cuarto, vacío el contenido o el "value" del input al que estoy haciendo referencia mediante "txtInput" (txtInput.value = '';) -> puedo hacer referencia al input mediante "txtInput" gracias a que, en una constante con ese nombre ("txtInput"), estoy almacenando su selección a traves de la clase que tiene el input, la cual es ".new-todo". Es decir, en una constante, almaceno un querySelector al elemento con la clase ".new-todo", el elemento con esa clase es el <input>, por ende, si selecciono un elemento con esa clase, estoy seleccionando el <input>

*/



// Evento para marcar "to do" como completado (agregar clase "completed" y cambiar el valor de la propiedad "completado" de la instancia de mi clase "Todo" a "true" o "false" según corresponda)
// Va a marcar como completado el "to do" o instancia de mi clase "Todo" cuando haga click en el "checkbox", le va a agregar la clase "completed" que contiene los estilos de un "to do" tachado y en gris, además de cambiar el valor de la propiedad "completado" a "true o false" de la instancia de la clase "Todo" a la que esté haciéndole click con el "check"

divTodoList.addEventListener( 'click', (event) => {

	const nombreElemento = event.target.localName; // básicamente a través de esta referencia que estoy almacenando en la constante "nombreElemento" logro que mediante "event" se registre todo lo que sucede cuando hago click, en todo ese registro de lo que sucede cuando hago "click", hay muchas cosas que no necesito para el objetivo o lo que quiero lograr, entonces mediante "target" indico que solo me muestre la información "target" de a lo que estoy haciendo click, es decir, cuando hago click en un elemento del DOM se registra todo lo que sucede, pero a mi solo me interesa ver la información respecto al "target" de lo que estoy clickeando, así que mediante "target" indico que solo quiero ver eso de mi evento, el target me muestra el tipo de elemento HTML al que le estoy haciendo click; luego a través del "localName", le digo que solo me muestre de ese elemento HTML al que le hice click, el nombre del elemento HTML como si fuese un string. Por ejemplo, si hice click a: "<label> Ejemplo </label>", solo me muestre: "label", todo eso gracias al "localName"
	// el valor que va a arrojar esto es: input, label, button, etc

	const todoElemento	 = event.target.parentElement.parentElement; // si yo dejase "event.target" e hiciese click en un "input", lo que obtendría seria algo así "<input> Ej </input>", dicho eso, lo que me interesa es que cuando haga click en el "check" de completado, pueda llegar al elemento "<li>" de cada "to do" y cambiar su clase a "completed", además de cambiar la propiedad "completado" (de "true" a "false" o viceversa) de la instancia de mi clase a la que estoy haciendo referencia o a la que estoy haciéndole click en el check de "completado" , entonces, necesito para eso llegar al elemento <li> porque ahí es donde se guarda el ID y la clase que me va a permitir cambiar a "completed mi "to do" o mi instancia de la clase "Todo". A través de: ".parentElement" yo puedo ir escalando en niveles HTML, si le hice click a un "label" que está dentro de mi elemento <li>, entonces con ".parentElement" yo puedo ir un nivel más arriba, en este caso, si yo hago click en un "to do", tengo que escalar dos niveles más arriba para llegar al elemento <li>, por eso se colocaron dos ".partenElement.parentElement"

	const todoId 		 = todoElemento.getAttribute('data-id'); // una vez que pudimos llegar al elemento <li> de nuestro HTML que nos interesa (en la constante "todoElemento"), lo que hago ahora, es extraer de ese elemento <li> su atributo HTML "data-id" el cual contiene el ID del "to do" o, en otras palabras, contiene como valor la propiedad "id" de esa instancia de nuestra clase "Todo"

	if ( nombreElemento.includes('input') ) { // si lo que arroja la constante "nombreElemento" incluye o contiene "input", significa que hizo click en el checkbox o palomilla de completado (ya que en HTML eso es un 'input'), y si hizo click en el check, se debe ejecturar lo que está entre {} del "if" 

		listaDeTareas.estadoTodo( todoId ); // cambia el valor de la propiedad "completado" de la instancia de mi clase "Todo" a la que le estoy haciendo click, a través del ID que tiene dicha instancia de mi clase "Todo". A través de ese ID, identifica cuál instancia de mi clase "Todo" está siendo clickeada, o a cuál "to do" le estoy haciendo click, y le cambia el valor de la propiedad "completado" al "to do" con ese ID. Lo que yo le paso como argumento a este método es el ID del "to do" al que le tengo que cambiar el valor de la propiedad "completado"... y el método lo que hace es ver el valor que tiene la propiedad "completado" de ese "to do" y lo que hace es cambiarla por lo opuesto mediante "!todo.completado"
		todoElemento.classList.toggle( 'completed' ); // me interesa ahora agregar la clase "completed" en caso de hacer click en el "input" o "check", y sacar la clase cuando el check ya esté marcado el "check", entonces, para ello debemos acceder al elemento <li> que es quien recibe esa clase, a través de la constante "todoElemento" accedemos al elemento <li> cuando hago click en algun "to do" o instancia de mi clase "Todo", luego, mediante "classList" hacemos referencia a todas las clases que contiene ese elemento <li> (es decir, con todoElemento.classList obtendríamos una lista de todas las clases que contiene el elemento <li> al que está haciendo referencia en la constante "todoElemento"), una vez que obtenemos el listado de todas las clases que contiene el elemento al que está haciendo referencia en la constante "todoElemento", mediante la instrucción o método "toggle" le decimos que agregue o saque una clase de acuerdo a si se encuentra o no se encuentra en ese listado de clases del elemento <li> al que estoy haciendo referencia mediante la constante "todoElemento". La clase que va a buscar si está o no está en ese listao es la que le pasamos entre paréntesis, en este caso le pedimos que busque la clase: "( 'completed' )", de esta forma, mediante el "toggle" se verifica que la clase "completed" se encuentra en la lista de clases (classList) del elemento <li> al que estoy haciendo referencia mediante la constante "todoElemento" y si se encuentra la borra, y si no se encuentra la agrega.

	} else if ( nombreElemento.includes('button') ) { // quiere decir que si el nombre del elemento que tocó el usuario dentro de nuestra aplicación corresponde a "button", se debe ejecutar el código entre llaves, el cual elimina la estructura HTML del "todo" del DOM // le estoy diciendo que si el usuario tocó dentro de la estructura HTML de un "todo" el elemento "button" (correspondiente a la "X" que simboliza el borrado de un "todo", entonces tiene que ejecutar el código entre llaves, el cual elimina el HTML del "todo")

		listaDeTareas.borrarTodo( todoId ); // va a ejecutar el método cuya explicación está en el archivo dentro del directorio "classes". ¿Qué elementos va a conservar? Va a conservar todos los elementos que tengan como valor de la propiedad "ID", un valor diferente al "ID" que le paso como argumento al método, es decir, solo va a eliminar de mi arreglo "this.todos" aquel "todo" que tenga el mismo "ID" que el "ID" que se envió como argumento ¿Que va a hacer el método? Barrer cada elemento de mi arreglo, el cual contiene dentro instancias de mi clase "Todo", va a buscar el valor de la propiedad "ID" de cada una de estas instancias, y si ese valor es diferente (!=) al ID que le pasé como argumento al método, va a conservar el "todo"... en otras palabras, me va a devolver un arreglo "this.todos" con todos los "todos" (o instancias de mi clase "Todo") que tengan como valor de su propiedad "ID" un valor diferente al "ID" que le envié como argumento al método, sacando de dicho arreglo, el "todo" que tenga un "ID" que coincida con el "ID" que le envié como argumento... como dijimos en la explicación del método, se elimina del arreglo "this.todos", pero sigue la estructura HTML del "todo", abajo de esta línea, el código que permite borrar el "todo" de la estructura HTML, además de borrar el "todo" del arreglo "this.todo" (de lo cual se encarga ésta linea)
		divTodoList.removeChild( todoElemento ); // va a borrar del "divTodoList" lo que le enviamos entre paréntesis, en este caso es la constante "todoElemento", la cual contiene la referencia al elemento <li> o la estructura HTML completa del "todo", de esa manera, le decimos que si hace click en el elemento "button" borre la referencia que almacena la constante "todoElemento", la referencia que almacena esa constante es el elemento "<li>" que compone al "todo", por ende, si hacemos click en el elemento "button", va a borrar el elemento <li> del HTML, el cual es la estructura del "todo"

	}

} )



// evento que me permite borrar los "todos" completados

btnBorrar.addEventListener( 'click', () => { // acá no enviamos como argumento el "event" debido a que no nos interesa conocer el "evento" o conocer el nombre del elemento o de la etiqueta HTML sobre la que se está haciendo click, o cuándo se hizo "click" o sobre qué se hizo "click", solo interesa que cuando se haga click en el botón (cuya referenica se guarda en la constante "btnBorrar"), se ejecute el código o el método que filtra en mi arreglo "this.todos" aquellos "todos" que están sin completar, devolviendome el mismo arreglo con los "todos" o instancias de mi clase "Todo" que tienen la propiedad "completado" como "false", y borra del arreglo los que tienen esa propiedad con el valor "true"

	listaDeTareas.borrarCompletados(); // método que se aplica sobre la constante "listaDeTareas", la cual almacena la referencia al arreglo o la clase "TodoList", la cual contiene el arreglo donde se van a almacenar las instancias de mi clase "Todo" o, en otras palabras, la clase "TodoList", cuya referencia se almacena en la constante "listaDeTareas", contiene el arreglo que dentro va a contener la totalidad de mis "todos" o instancias de mi clase "Todo". Este método que se aplica sobre la constante que contiene esa referencia, lo que hace es filtrar de mi arreglo "this.todos" (el cual se encuentra dentro de la clase "TodoList" cuya referencia está almacenada en la constante "listaDeTareas"), todos los "todos" o instancias de mi clase "Todo" que tengan como propiedad "completado" el valor "false", y me devuelve el mismo arreglo "this.todos" pero filtrando aquellos "todos" o instancias de la clase "Todo" que tengan la propiedad "completado" como "true", quitándo esos "todos" o instancias y devolviéndome un arreglo "this.todos" con ´únicamente las instancias o "todos" que tienen la propiedad "completado" como "false"
	// a través de éste método "borrarCompletados" únicamente los borra de mi arreglo "this.todos", pero no los borra del HTML

	// Borrar los elementos del HTML

	for ( let i = divTodoList.children.length-1; i >= 0; i-- ) { 
	// estoy creando la varianble "i", el valor de "i" es la cantidad de elementos "<li>" que hay dentro de mi "<ul>" (cuya referencia se guarda en la constante "divTodoList"), la constante "divTodoList" está almacenando una referencia a mi elemento <ul>, este elemento <ul> es una lista que contiene todos y cada uno de mis elementos "<li>", cada elemento "<li>" que esté dentro de mi "<ul>" representa la estructura HTML de un "todo" o una instancia de mi clase "Todo". Básicamente lo que le digo al ciclo "for" es que se ejecute siempre y cuando "i" sea mayor o igual a "0", y el valor de "i" es la cantidad de elementos <li> que hay dentro de mi <ul> MENOS 1, y a su vez, la cantidad de elementos <li> que hay dentro de mi <ul> depende de la cantidad de "todos" o instancias de mi clase "Todo" que yo haya insertado (append) a mi array "this.todos". Entonces, la cantidad de elementos <li> que haya dentro de mi <ul> va a depender de cuántos "todos" o instancias de mi clase "Todo" yo haya creado e insertado en mi array "this.todos" y en el HTML, si no hay "todos", la variable "i" va a ser igual a "-1" (porque "i" es igual a la cantidad de elementos <li> que hay en mi <ul>, es decir, el "length" de mi array "this.todos" menos UNO, entonces si no hay "todos" en mi array, el length es "0" y si le restamos UNO, da "-1", por ende, "i" es igual a "-1" y no se va a ejecutar el bucle, debido a que el bucle se va a ejecutar siempre que "i" sea mayor o igual a "0", si "i" es igual a "-1" entonces es menor a "0" y no se ejecuta), y como "i" es igual a "-1" no se va a seguir ejecutando el bucle, cada vez que se cumpla esa condición de que "i" sea mayor o igual a "0", se va a ejecutar el código y se va a restar "1" a "i" (i--), de esa forma, siempre se van a recorrer todos los elementos o "todos" que contenga mi arreglo "this.todos". Entonces, siempre que "i" sea igual o mayor a "0" se va a ejcutar lo que está entre llaves, y cada vez que se ejecute, se va a restar un punto a "i", de esa manera, se recorren todos los elementos de mi arreglo "this.todos". Entonces, si yo no tengo ningún elemento en mi arreglo, "i" va a ser igual a "-1" porque "i" es igual al "length" o cantidad de elementos que hay en mi arreglo MENOS "1", para poder recorrer todas las POSICIONES de mi arreglo "this.todos", recordemos que las posiciones de los arreglos comienzan desde el lugar "0" entonces para poder recorrer todos los "todos" o instancias de mi clase "Todo" necesito tambien recorrer la posición "0", es decir, la posición "0" también es un "todo", entonces, para poder llegar a ese todo tengo que poner que "i" debe ser igual a la cantidad o "length" de elementos que hay en mi arreglo o en mi elemento <ul> MENOS 1, y que el ciclo se ejecute aún "i" siendo igual a "0", es decir, el ciclo se ejecuta siempre que "i" sea mayor o igual a "0", para que no se ejecute más el ciclo, "i" debe ser igual a "-1", y la variable "i" va a ser igual a "-1" cuando ya no haya más "todos" en el arreglo, cuando ya recorrió hasta la posición "0" de mi arreglo.

		const elemento = divTodoList.children[i]; // la constante "elemento" está almacenando o es igual al último elemento de mi array "this.todo" o a mi último "todo" o a la última instancia de mi clase "Todo" que se encuentra dentro del array "this.todos"

		if ( elemento.classList.contains('completed') ) { // si "elemento" o la constante "elemento" que almacena la última posición o el último todo dentro de mi array "this.todos" tiene una clase llamada o que "contains" el nombre de 'completed', en caso de que dicha condición de "true" se debe ejecutar el código entre llaves

			divTodoList.removeChild( elemento );
			// entonces, si dentro del ciclo existe un "todo" o instancia de mi clase "Todo" que contengas (contains) la clase de "completed", se debe remover del HTML el "elemento" ("elemento" es una constante que almacena la referencia al elemento <ul>, el elemento "<ul>" es quien contiene dentro o es el padre de todos mis elementos <li>, cada elemento <li> es un "todo" o representa la estructura HTML de un "todo"). La constante "divTodoList" es quien almacena la referencia a ese elemento <ul> que contiene dentro o es padre de todos mis elementos <li>, de esa manera, aplicando el método "removeChild" sobre la constante que almacena la referencia al elemento padre de mis elementos <li> (que son la estructura HTML de cada "todo"), puedo remover "elemento", y "elemento" es el "todo" o instancia de mi clase "Todo" que se encuentra siendo recorrido actualmente por el ciclo "for", en el caso de que la instancia o "todo" que se encuentre recorriendo el ciclo "for" contenga (contains) la clase "completed", la condición del "if" se va a cumplir y va a borrar ese "elemento" o "todo" debido al "removeChild", el cual es un método que va a borar el "todo" que se encuentre siendo recorrido por el ciclo "for" ¿ Por qué ? Porque se cumplio la condicion del "if" y el "todo" que se encontraba siendo recorrido por el "for" (lo sé gracias a la referencia que se almacena en la constante "elemento") contenía la clase "completed", por ende, se cumplió la condición del "if" y al cumplirse dicha condición lógica y entrar en el "if", se borra el elemento que se encuentra siendo recorrido actualmente por el "for", gracias a la referencia que almacena la constante "elemento" puedo saber e identificar cuál es la instancia o "todo" que está recorriendo el ciclo "for", y si dicha instancia contiene la clase mencionada entonces borra dicho elemento/instancia/"todo"... de no cumplirse la condición del if, porque la instancia o "todo" que se encuentra siendo recorrida del array "this.todo" no contiene esa clase, simplemente saltea el "if" y sigue con el bucle, sin borrar esa instancia o "todo" que NO contiene la clase "completed"

		}

	}

} )

// Evento, que cuando se haga click en el botón "Borrar completados" (cuya referencia se está haciendo mediante la constante btnBorrar, y la clase ".clear-completed" que tiene dicho botón en el HTML), deberá ejecutar el código encapsulado entre las llaves de mi función de flecha dentro del método "addEventListener", método el cual me permite ejecutar un código o función cuando se detecta un evento en mi apliación o web, el "evento" en este caso, es el click al botón "Borrar completados", el cual mediante su clase de ".clear-completed" se está almacenando en la constante "btnBorrar". Cuando suceda el "evento" de "click" sobre el botón de "Borrar completados", cuya referencia se almacena en la constante "btnBorrar" mediante su clase ".clear-completed", cuando se dé ese "evento" de "click" sobre la referencia que está almacenando esa constante, se va a ejecutar el código entre llaves de la función que está dentro del método


// Evento para que cuando se haga click en los botones de "filtro" o botones que tiene el sitio para filtrar, se genere el evento que filtre efectivamente

ulFiltros.addEventListener('click', (event) => {

	const filtro = event.target.text;
	if ( !filtro ) { return; }


	// agregar clase de "selected" al filtro/botón que se esté aplicando, para que tenga el estilo que indica que ese es el filtro que se está aplicando
	aFiltro.forEach( elem => elem.classList.remove('selected') ); // borro de cada botón que me permite filtrar, la clase de "selected" que indica que ese es el filtro que se está aplicando, para darsela al botón o filtro que realmente se esté aplicando
	event.target.classList.add('selected');
	// event.target hace referencia al <li> o botón de filtro al que le estoy haciendo click. Entonces quiero que a ese botón de filtro que le estoy haciendo click, le añada la clase "selected" (event.target.classList.add('selected')). De esa forma se le aplican los estilos de la clase "selected" al botón de filtro al que le estoy haciendo click, es decir al botón que está filtrando efectivamente. Si yo le hago click al botón de filtro "Completados", se le va a agregar la clase "selected" a ese botón, lo cual es lógico y correcto, ya que cuando hago click en "Completados" me va a mostrar los "todos" que tengan esa clase "completed" y al resto los va a ocultar, es decir, va a filtrar los "todos", entonces está correcto que se le otorgue la clase "selected" al botón de filtro "Completados" cuando le hago click porque cuando le hago click ese va a ser el filtro activo, y mediante esa clase "selected" estoy indicando que ese es el filtro activo


	for (const elemento of divTodoList.children) { // El "for" va a recorrer cada elemento dentro de mi arreglo "divTodoList.children" y lo va a almacenar en cada iteración en la constante "elemento" ... creo una constante llamada "elemento" de cada uno de los elementos que contiene el arreglo "divTodoList.children", eso es lo que estoy diciendo acá, que se cree una constante "elemento" de cada uno de los elementos que hay dentro del array "divTodoList.children". Entonces, cada uno de los elementos que haya dentro de mi arreglo, en cada iteración del bucle o ciclo "for", van a ser asignados o almacenados en la constante "elemento". El ciclo "for" va a recorrer cada uno de los elementos que hay dentro de mi arreglo, y en cada iteración, ese elemento se va a guardar en la constante "elemento"

		// quitar la clase "hidden" cada vez que hacemos click en algun elemento dentro de mi <ul>
		elemento.classList.remove('hidden');
		
		const completado = elemento.classList.contains('completed'); // estoy preguntando si cada "elemento" o "todo" dentro mi arreglo "divTodoList.children" contiene la clase "completed", y almaceno eso en la constante "completado". Si contiene esa clase, entonces el "todo" está Competado, y si no contiene esa clase, el "todo" NO está Completado, está Pendiente

		// switch que me permite hace una accion u otra en base a lo que sea igual la constante "filtro", si la constante filtro es igual a "Pendientes", ingresa al "case: 'Pendientes'" y verifica que si "elemento" (cada "todo" dentro de mi arreglo "divTodoList") contiene la clase "completed" (es lo que almacena la constante "completed"), entonces le agrega la clase "hidden", de esa manera se le agrega esa clase a todos los que tengan también la clase "completed" y así se ocultan los que tienen esas clase y por consiguiente están completados, y solo se muestran los que NO estan completados, es decir, los que están pendientes. El otro "case" es lo contrario, si NO contiente la clase "completed" (!completado), entonces se le agrega la clase "hidden", es decir, si el "elemento" no contiene la clase "completed" se le agrega la clase "hidden", de esa forma, a todos los "todos" que no tengan esa clase y por consiguiente no estén completados se les va a agregar esa clase y se van a ocultar, dejando solo los "todos" que tengan esa clase y estén completados... en otras palabras se ocultan todos los que no tienen la clase "completed", dejando o mostrando solo aquellos "todos" que están completados unicamente, que es el obejtivo del "case: 'Completados'", agregar la clase "hidden" a los "todos" que no tengan la clase "completed", ocultando aquellos que no están completados y dejando solo para mostrar los que SI están completados
		switch ( filtro ) {

			case 'Pendientes':
				if (completado) {
					elemento.classList.add('hidden');
				}
			break

			case 'Completados':
				if (!completado) {
					elemento.classList.add('hidden');
				}
			break
			
		}

	}

} )